<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">

<!--Converted with LaTeX2HTML 99.1 release (March 30, 1999)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>PowerForms:
Declarative Client-Side Form Field Validation</TITLE>
<META NAME="description" CONTENT="PowerForms:
Declarative Client-Side Form Field Validation">
<META NAME="keywords" CONTENT="powerform">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
<META NAME="Generator" CONTENT="LaTeX2HTML v99.1 release">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<STYLE TYPE="text/css">
<!--
BODY { BACKGROUND-COLOR: #ffffff; FONT-FAMILY: arial, times new roman, sans-serif; }
A:link, A:visited, A:active { TEXT-DECORATION: none; FONT-WEIGHT: bold; COLOR: #0000FF}

H2, H3, H4, H5 { TEXT-ALIGN: left; FONT-WEIGHT: bold; }
H6 { TEXT-ALIGN: center; FONT-WEIGHT: bold; FONT-SIZE: small; }
H6.CAPTION { TEXT-ALIGN: center; FONT-WEIGHT: bold; FONT-SIZE: small; FONT-STYLE: italic; }

P { TEXT-INDENT: 1em; MARGIN-TOP: 0; MARGIN-BOTTOM: 0}
P.CODE { TEXT-INDENT: 0; COLOR: #FF0000; }

UL, OL { MARGIN-LEFT: 1em; FONT-SIZE: medium; }
UL { list-style: square; }
LI { FONT-SIZE: small; }
UL EM, OL EM { FONT-WEIGHT: bold; }
CODE, CITE { FONT-WEIGHT: bold; }

BLOCKQUOTE { MARGIN-LEFT: 1em; MARGIN-RIGHT: 1em }
IMG { VERTICAL-ALIGN: top; ALIGN: center; }
SUP { COLOR: #0000FF; FONT-SIZE: small; }
TT,PRE { FONT-FAMILY: monospace; }
-->
</STYLE>

</HEAD>

<BODY >

<P>

<P>

<CENTER><H1>PowerForms:
<BR>Declarative Client-Side Form Field Validation</H1>
<P ALIGN="CENTER"><STRONG><A NAME="tex2html2"
 HREF="http://www.brics.dk/~brabrand">Claus Brabrand</A>
 - 
  <A NAME="tex2html3"
 HREF="http://www.brics.dk/~amoeller">Anders Møller</A>
 - 
  <A NAME="tex2html4"
 HREF="http://www.brics.dk/~ricky">Mikkel Ricky</A>
 - 
  <A NAME="tex2html5"
 HREF="http://www.brics.dk/~mis">Michael I. Schwartzbach</A>
<BR>
BRICS, Department of Computer Science
<BR>
  Aarhus University, Denmark
<BR>
  <FONT SIZE="-1"><A NAME="tex2html1"
 HREF="mailto:brabrand@brics.dk,amoeller@brics.dk,ricky@brics.dk,mis@brics.dk"><TT> {brabrand,amoeller,ricky,mis}&#64;brics.dk</TT></A> 
</FONT></STRONG></P>
</CENTER>

<P>

<H3>Abstract:</H3>
<DIV>
  All uses of HTML forms may benefit from validation of the specified input field values.
  Simple validation matches individual values against specified formats,
  while more advanced validation may involve interdependencies of form fields.

<P>
There is currently no standard for specifying or implementing such validation. Today,
  CGI programmers often use Perl libraries for simple server-side validation or 
  program customized JavaScript solutions for client-side validation.

<P>
We present PowerForms, which is an add-on to HTML forms that allows a purely declarative
  specification of input formats and sophisticated interdependencies of form fields. While our
  work may be seen as inspiration for a future extension of HTML, it is also available for 
  CGI programmers today through a preprocessor that translates a PowerForms document into a
  combination of standard HTML and JavaScript that works on all combinations of platforms and
  browsers. 

<P>
The definitions of PowerForms formats are syntactically disjoint from the form itself, which 
  allows a modular development where the form is perhaps automatically generated by other tools and
  the formats and interdependencies are added separately.

<P>
PowerForms has a clean semantics defined through a fixed-point process that resolves the
  interdependencies between all field values. Text fields are
  equipped with status icons (by default traffic lights) that continuously reflect the
  validity of the text that has been entered so far, thus providing immediate
  feed-back for the user. For other GUI components the available options are dynamically 
  filtered to present only the allowed values.

<P>
PowerForms are integrated into the <TT> &lt;bigwig&gt;</TT> system for
  generating interactive Web services, but is also freely available in
  an Open Source distribution as a stand-alone package.
</DIV>
<P>

<P>

<H1><A NAME="SECTION00010000000000000000">
Introduction</A>
</H1>

<P>
We briefly review some relevant aspects of HTML forms.  The CGI
protocol enables Web services to receive input from clients through
forms embedded in HTML pages. An HTML form is comprised of a number of
input fields each prompting the client for information.

<P>
The visual rendering of an input field and how to enter the
information it requests is determined by its type. The most widely
used fields range from expecting lines of textual input to providing
choices between a number of fixed options that were determined at the
time the page was constructed. Many of the fields only differ in
appearance and are indistinguishable to the server in the sense that
they return the same kind of information.  Fields of type <TT> text</TT>
and <TT> password</TT>, although rendered differently, each expect one
line of textual input from the client.  Multiple lines of textual
input can be handled through the <TT> textarea</TT> field. The fields of
types <TT> radio</TT> and <TT> select</TT> both require exactly one choice
between a number of static options, whereas an arbitrary number of
choices are permitted by the <TT> checkbox</TT> and <TT> select</TT> (<TT> 
  multiple</TT>) fields. Individual <TT> radio</TT> and <TT> checkbox</TT> fields
with common name may be distributed about the form and constitute a
group for which the selection requirements apply.  The options of a
<TT> select</TT> field, on the other hand, are grouped together in one
place in the form. In addition, there are the more specialized
fields, <TT> image</TT>, <TT> file</TT>, <TT> button</TT>, and <TT> hidden</TT>, which
we shall not treat in detail.  Finally, two fields control the
behavior of the entire form, namely <TT> reset</TT> and <TT> submit</TT>,
which respectively resets the form to its initial state and submits
its contents to the server.

<P>

<H2><A NAME="SECTION00011000000000000000">
Input validation</A>
</H2>

<P>
Textual input fields could possibly hold anything. Usually, the client
is expected to enter data of a particular form, for instance a number,
a name, a ZIP-code, or an e-mail address. The most frequent solution
is to determine on the server whether the submitted data has the
required form, which is known as <EM> server-side input validation</EM>.
If some data are invalid, then those parts are presented once again
along with suitable error messages, allowing the client to make the
necessary corrections. This process is repeated until all fields
contain appropriate data. This solution is simple, but it has three
well-known drawbacks:

<P>

  <UL>
<LI>it takes time;</LI>
<LI>it causes excess network traffic; and</LI>
<LI>it requires explicit server-side programming.</LI>
</UL>

<P>
Note that these drawbacks affect all parties involved. The client is
clearly annoyed by the extra time incurred by the round-trip to the
server for validation, the server by the extra network traffic and
``wasted'' cycles, and the programmer by the explicit programming
necessary for implementing the actual validation and re-showing of the
pages. An obvious solution to the first two drawbacks is to move the
validation from the server to the client, yielding <EM> client-side
  input validation</EM>.  The third drawback, however, is only partially
alleviated. All the details of re-showing pages are no longer
required, but the actual validation still needs to be programmed.

<P>
The move from server-side to client-side also opens for another
important benefit, namely the possibility of performing the validation
<EM> incrementally</EM>. The client no longer needs to click the submit
button before getting the validation report. This allows errors to be
be signalled as they occur, which clearly eases the task of correctly
filling out the form.

<P>

<H2><A NAME="SECTION00012000000000000000">
Field interdependencies</A>
</H2>

<P>
Another aspect of validation involves interdependent fields.  Many
forms contain fields whose values may be constrained by values entered
in other fields.  Figure&nbsp;<A HREF="http://www.brics.dk/bigwig/publications/powerform/powerform.html#fig:questionnaire">1</A> exhibits a simple
questionnaire from a conference, in which participants were invited to
state whether they have attended past conferences and if so, how this
one compared. The second question clearly depends on the first, since
it may only be answered if the first answer was positive. Conversely,
an answer to the second question may be required if the first answer was
``Yes''.

<P>

<P></P>
<DIV ALIGN="CENTER"><A NAME="fig:questionnaire"></A><A NAME="91"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 1:</STRONG>
Conference questionnaire.</CAPTION>
<TR><TD><IMG WIDTH="423" HEIGHT="138" BORDER="0"
SRC="www8questionnaire.gif" ALT="WWW8 conference questionnaire"></TD></TR>
</TABLE>
</DIV><P></P>

<P>
Such interdependencies are almost always handled on the server, even
if the rest of the validation is addressed on the client-side. The
reason is presumably that interdependencies require some tedious
and delicate JavaScript code. This kind of validation is explicitly requested in
the W3C working draft on extending forms&nbsp;[<A
 HREF="http://www.brics.dk/bigwig/publications/powerform/powerform.html#xhtml-forms">13</A>].
One could easily imagine more advanced dependencies.  Also, it would
be useful if illegal selections could somehow automatically be
deselected.

<P>

<H2><A NAME="SECTION00013000000000000000">
JavaScript programming</A>
</H2>

<P>
Traditionally, client-side input validation is implemented in
JavaScript. We will argue that this may not be the best choice for
most Web authors.

<P>
First of all, using a general-purpose programming language for a
relatively specific purpose exposes the programmer to many unnecessary
details and choices. A small high-level domain-specific
language dedicated to input validation would involve only relevant
concepts and thus be potentially easier to learn and use.  Many
assisting libraries exist&nbsp;[<A
 HREF="http://www.brics.dk/bigwig/publications/powerform/powerform.html#javascript-lib">6</A>], but must still be
used in the context of a full programming language.

<P>
Secondly, JavaScript code has an operational form, forcing the
programmer to think about the order in which the fields and their
contents are validated.  However, the simplicity of the input
validation task permits the use of a purely <EM> declarative</EM>
approach.  A declarative specification abstracts away operational
details, making programs easier to read, write, and maintain. Also,
such an approach is closer to composing HTML than writing JavaScript,
making input validation available to more people. As stated in the W3C
working draft on extending forms:
<BLOCKQUOTE>
``It should be possible to define a rich form, including
validations, dependencies, and basic calculations without the use of a
scripting language.''

</BLOCKQUOTE>
Our solution will precisely include such mechanisms for validations and
dependencies.

<P>
Finally, the traditional implementation task is further complicated by
diverging JavaScript implementations in various browsers. This forces
the programmer to stay within the subset of JavaScript that is
supported by all browsers--a subset that may be hard to identify. In
fact, a number of sites and FAQs are dedicated to identifying this
subset&nbsp;[<A
 HREF="http://www.brics.dk/bigwig/publications/powerform/powerform.html#javascript-faq">15</A>,<A
 HREF="http://www.brics.dk/bigwig/publications/powerform/powerform.html#javascript-forms">9</A>].  A domain-specific
language could be compiled into this common subset of JavaScript,
implying that only the compiler writer will be concerned with this
issue.

<P>

<H2><A NAME="SECTION00014000000000000000">
Our solution: PowerForms</A>
</H2>

<P>
As argued above, our solution is to introduce a high-level <EM> 
  declarative</EM> and <EM> domain-specific</EM> language, called
PowerForms, designed for incremental input validation.

<P>
Section&nbsp;<A HREF="http://www.brics.dk/bigwig/publications/powerform/powerform.html#sec:validation">2</A> presents our solution for simple
validation; Section&nbsp;<A HREF="http://www.brics.dk/bigwig/publications/powerform/powerform.html#sec:interdependencies">3</A> extends this to handle
field interdependencies; Section&nbsp;<A HREF="http://www.brics.dk/bigwig/publications/powerform/powerform.html#sec:avoidingmore">4</A> exhibits how
other common uses of JavaScript also can be handled through
declarative specification; Section&nbsp;<A HREF="http://www.brics.dk/bigwig/publications/powerform/powerform.html#sec:translation">5</A> presents the
overall strategy of the translation to JavaScript; and
Section&nbsp;<A HREF="http://www.brics.dk/bigwig/publications/powerform/powerform.html#sec:package">6</A> describes the availability of the
PowerForms packages.

<P>

<H2><A NAME="SECTION00015000000000000000">
Related work</A>
</H2>

<P>
Authoring systems like Cold Fusion&nbsp;[<A
 HREF="http://www.brics.dk/bigwig/publications/powerform/powerform.html#coldfusion">7</A>] can automate
server-side verification of some simple formats, but even so the
result is unsatisfactory. A typical response to invalid data is shown
in Figure&nbsp;<A HREF="http://www.brics.dk/bigwig/publications/powerform/powerform.html#fig:coldfusion">2</A>. It refers to the internal names of
input fields which are unknown to the client, and the required
corrections must be remembered when the form is displayed again.

<P></P>
<DIV ALIGN="CENTER"><A NAME="fig:coldfusion"></A><A NAME="116"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 2:</STRONG>
Typical server-side validation.</CAPTION>
<TR><TD><IMG WIDTH="680" HEIGHT="368" BORDER="0" SRC="coldfusion.gif" ALT="Typical server-side validation"></TD></TR>
</TABLE>
</DIV><P></P>

<P>
Active Forms&nbsp;[<A
 HREF="http://www.brics.dk/bigwig/publications/powerform/powerform.html#activeforms">14</A>] is based on a special browser
supporting Form Applets programmed as Tcl scripts. It does not offer
high-level abstractions or integration with HTML.

<P>
Web Dynamic Forms&nbsp;[<A
 HREF="http://www.brics.dk/bigwig/publications/powerform/powerform.html#webdynamicforms">8</A>] offer an ambitious and
complex solution. They propose a completely new form model that is
technically unrelated to HTML and exists entirely within a Java
applet. Inside this applet, they allow complicated interaction
patterns controlled through an event-based programming model in which
common actions are provided directly and others may be programmed in
Java. When a form is submitted, the data are extracted from the applet
and treated as ordinary HTML form data. The intervening years have
shown that Web authors prefer to use standard HTML forms instead and
then program advanced behavior in JavaScript.  Thus, our simpler
approach of automatically generating this JavaScript code remains
relevant.  An important reason to stay exclusively with HTML input
fields is that they can be integrated into HTML tables to control
their layout.

<P>
The XHTML-FML language&nbsp;[<A
 HREF="http://www.brics.dk/bigwig/publications/powerform/powerform.html#fml">12</A>] also provides a means for
client-side input validation by adding an attribute called <TT> ctype</TT> to
textual input fields. However, this attribute is restricted to a (large)
set of predefined input validation types and there is no support for
field inderdependency.

<P>
Our PowerForms notation is totally declarative and
requires no programming skills.  Furthermore, it is modular in the sense
that validation can be added to an input field in an existing HTML
form without knowing anything but its name.  The validation markup
being completely separate from the form markup allows the layout of a
form to be redesigned at any time in any HTML editor.

<P>

<H1><A NAME="SECTION00020000000000000000"></A>
<A NAME="sec:validation"></A><BR>
Validation of Input Formats
</H1>

<P>
The language is based on regular expressions 
embedded in HTML that
is subsequently translated into a combination of standard HTML and
JavaScript. This approach benefits from an efficient implementation
through the use of finite-state automata which are interpreted by
JavaScript code.

<P>
Named formats may be associated to fields whose values are then
required to belong to the corresponding regular sets. The client is
continuously receiving feedback, and the form can only be submitted
when all formats are satisfied. The server should of course perform a
double-check, since the JavaScript code is open to tampering.

<P>
Regular expressions denoting sets of strings are a simple and familiar
formalism for specifying the allowed values of form fields.  As we
will demonstrate, all reasonable input formats can be captured in this
manner. Also, the underlying technology of finite-state automata gives
a simple and efficient implementation strategy.

<P>

<H2><A NAME="SECTION00021000000000000000">
Syntax</A>
</H2>

<P>
We define a rich XML syntax&nbsp;[<A
 HREF="http://www.brics.dk/bigwig/publications/powerform/powerform.html#bray98:_exten_markup_languag_xml">5</A>] for regular expressions on 
strings: <TT></TT><PRE><TT>
&nbsp;&nbsp;<I>regexp</I> ::= &lt;const value=<I>stringconst</I>/&gt; |
<BR>             &lt;empty/&gt; |
<BR>             &lt;anychar/&gt; |
<BR>             &lt;anything/&gt; |
<BR>             &lt;charset value=<I>stringconst</I>/&gt; |
<BR>             &lt;fix low=<I>intconst</I> high=<I>intconst</I>/&gt; |
<BR>             &lt;relax low=<I>intconst</I> high=<I>intconst</I>/&gt; |
<BR>             &lt;range low=<I>charconst</I> high=<I>charconst</I>/&gt; |
<BR>             &lt;intersection&gt; <I>regexp</I>* &lt;/intersection&gt; |
<BR>             &lt;concat&gt; <I>regexp</I>* &lt;/concat&gt; |
<BR>             &lt;union&gt; <I>regexp</I>* &lt;/union&gt; |
<BR>             &lt;star&gt; <I>regexp</I> &lt;/star&gt; |
<BR>             &lt;plus&gt; <I>regexp</I> &lt;/plus&gt; |
<BR>             &lt;optional&gt; <I>regexp</I> &lt;/optional&gt; |
<BR>             &lt;repeat count=<I>intconst</I>&gt; <I>regexp</I> &lt;/repeat&gt;
<BR>             &lt;repeat low=<I>intconst</I> high=<I>intconst</I>&gt; <I>regexp</I> &lt;/repeat&gt;
<BR>             &lt;complement&gt; <I>regexp</I> &lt;/complement&gt; |
<BR>             &lt;regexp exp=<I>stringconst</I>/&gt; |
<BR>             &lt;regexp id=<I>stringconst</I>&gt; <I>regexp</I> &lt;/regexp&gt; |
<BR>             &lt;regexp idref=<I>stringconst</I>/&gt; |
<BR>             &lt;regexp uri=<I>stringconst</I>/&gt; |
<BR>             &lt;include uri=<I>stringconst</I>/&gt;
</TT></PRE><TT></TT>

Here, <TT> <I>regexp</I>*</TT> denotes zero or more repetitions of <TT> 
  <I>regexp</I></TT>.  The nonterminals <TT> <I>stringconst</I></TT>, <TT> 
  <I>intconst</I></TT>, and <TT> <I>charconst</I></TT> have the usual
meanings.  

<P>
Note that the verbose XML syntax also allows standard Perl syntax for regular expressions through the
construct <TT> &lt;regexp exp=<I>stringconst</I>/&gt;</TT>. Our full syntax is however more general, since it
includes intersection, general complementation, import mechanisms, and a richer set of primitive
expressions.

<P>
A regular expression is associated with a form field through a declaration:<TT></TT><PRE><TT>
&nbsp;&nbsp;<I>formatdecl</I> ::= &lt;format name=<I>stringconst</I>
<BR> 		 	 help=<I>stringconst</I>
<BR>		 	 error=<I>stringconst</I>&gt;
<BR>                 <I>regexp</I>
<BR>                 &lt;/format&gt;
</TT></PRE><TT></TT>

The value of the optional <TT> help</TT> attribute will appear in the
status line of the browser when the field has focus; similarly, the
value of the optional <TT> error</TT> attribute will appear if the field
contains invalid data.

<P>
The format takes effect for a form field of type type <TT> text</TT>, <TT> 
  password</TT>, <TT> select</TT>, <TT> radio</TT>, or <TT> checkbox</TT> whose name
is the value of the <TT> name</TT> attribute.  The need for input formats
is perhaps only apparent for <TT> text</TT> and <TT> password</TT> fields, but
we need the full generality later in Section&nbsp;<A HREF="http://www.brics.dk/bigwig/publications/powerform/powerform.html#sec:interdependencies">3</A>.

<P>

<H2><A NAME="SECTION00022000000000000000">
Semantics of regular expressions</A>
</H2>

<P>
Each regular expression denotes an inductively defined set of strings.
The <TT> const</TT> element denotes the singleton set containing its <TT> 
  value</TT>. The <TT> empty</TT> element denotes the empty set.  The <TT> 
  anychar</TT> element denotes the set of all characters. The <TT> 
  anything</TT> element denotes the set of all strings.  The <TT> charset</TT>
denotes the set of characters in its <TT> value</TT>.  The <TT> fix</TT>
element denotes the set of numerals from <TT> low</TT> to <TT> high</TT> all
padded with leading zeros to have the same length as <TT> high</TT>. The
<TT> relax</TT> element denotes the set of numerals from <TT> low</TT> to <TT> 
  high</TT>.  The <TT> range</TT> element denotes the set of singleton strings
obtained from the characters <TT> low</TT> to <TT> high</TT>. The <TT> 
  intersection</TT> element denotes the intersection of the sets denoted
by its children. The <TT> concat</TT> element denotes the concatenation of
the sets denoted by its children.  The <TT> union</TT> element denotes the
union of the sets denoted by its children.  The <TT> star</TT> element
denotes zero or more concatenations of the set denoted by its child.
The <TT> plus</TT> element denotes one or more concatenations of the set
denoted by its child.  The <TT> optional</TT> element denotes the union of
the set containing the empty string and the set denoted by its child.
The <TT> repeat</TT> element with attribute <TT> count</TT> denotes a fixed power of the set denoted by
its child. The <TT> repeat</TT> element with attributes <TT> low</TT> and <TT> high</TT> denotes
the corresponding interval of powers of the set denoted by its child, where <TT> low</TT>
defaults to zero and <TT> high</TT> to infinity.
The <TT> complement</TT> element denotes the complement of the
set denoted by its child. 
The <TT> regexp</TT> element with attribute <TT> exp</TT> denotes the set 
denotes by its attribute value interpreted as a standard Perl regular expression.
The <TT> regexp</TT> element with attribute <TT> id</TT> denotes the same
set as its child, but in addition names it by the value of <TT> id</TT>.
The <TT> regexp</TT> element with attribute <TT> idref</TT> denotes the same set as the
regular expression whose name is the value of <TT> idref</TT>.
It is required that each <TT> id</TT> value is unique throughout
the document and that each <TT> idref</TT> value matches some <TT> id</TT>
value. 
The <TT> regexp</TT> element with attribute <TT> uri</TT> denotes the set recognized by
a precompiled automaton.
The <TT> include</TT> element performs a textual insertion of the
document denoted by its <TT> url</TT> attribute.

<P>

<H2><A NAME="SECTION00023000000000000000">
Semantics of format declarations</A>
</H2>
The effect on a form field of a regular expression denoting the set
<em>S</em> is defined as follows.  For a <TT> text</TT> or <TT> password</TT> field,
the effect is to decorate the field with one of four annotations:

  <UL>
<LI><EM> green light</EM>, if the current value is a member of <em>S</em>;</LI>
<LI><EM> yellow light</EM>, if the current value is a proper prefix of a
  member of <em>S</em>;</LI>
<LI><EM> red light</EM>, if the current value is not a prefix of a
  member of a non-empty <em>S</em>; or</LI>
<LI><EM> n/a</EM>, if <em>S</em> is the empty set.</LI>
</UL>
The form cannot be submitted if it has a yellow or red light.  The
default annotations, which are placed immediately to the right of the
field, are tiny icons inspired by traffic lights, but they can be
customized with arbitrary images to obtain a different look and feel
as indicated in Figure&nbsp;<A HREF="http://www.brics.dk/bigwig/publications/powerform/powerform.html#fig:icons">3</A>.  Other annotations, like
colorings of the input fields, would also seem reasonable, but current
limitations in technology make this impossible.

<P></P>
<DIV ALIGN="CENTER"><A NAME="fig:icons"></A><A NAME="278"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 3:</STRONG>
Different styles of status icons.</CAPTION>
<TR><TD><IMG WIDTH="446" HEIGHT="275" BORDER="0" SRC="icons.gif" ALT="Different styles of status icons"></TD></TR>
</TABLE>
</DIV><P></P>

<P>
For a <TT> select</TT> field, the effect is to filter the <TT> option</TT>
elements, allowing only those whose values are members of <em>S</em>.  There
is a slight deficiency in the design of a singular <TT> select</TT>, since
it in some browser implementations will always show one selected
element.  To account for the situation where no option is allowed, we
introduce an extension of standard HTML, namely <TT> &lt;option
  value="foo" error&gt;</TT> which is legal irrespective of the format.  The
form cannot be submitted if the <TT> error</TT> option is selected, unless
<em>S</em> is the empty set.

<P>
For a <TT> radio</TT> field, the effect is that the button can only be
depressed if its value is a member of <em>S</em>; if <em>S</em> is not the empty
set, then the form cannot be submitted unless one button is depressed.
Note that the analogue of the <TT> error</TT> option is the case where no
button is depressed.

<P>
For a <TT> checkbox</TT> field, the effect is that the button can only be
depressed if its value is a member of <em>S</em>.

<P>
Using our mechanism, it is possible to create a <EM> deadlocked</EM>
form that cannot be submitted. The simplest example is the following,
assuming the input field below is the only one in the <TT> radio</TT>
button group named <TT> foo</TT>:
<PRE>

   &lt;input type="radio" name="foo" value="aaa"&gt;
   &lt;format name="foo"&gt;&lt;const value="bbb"&gt;&lt;/format&gt;
</PRE>
Regardless of whether the radio button <TT> foo</TT> is depressed or not,
<TT> foo</TT> will never satisfy its requirements.  Thus, the form can
never be submitted.  This behavior exposes a flaw in the design of the
form, rather than an inherent problem with our mechanisms.

<P>

<H2><A NAME="SECTION00024000000000000000">
Examples</A>
</H2>

<P>
All reasonable data formats can be expressed as regular expressions,
some more complicated than others. A simple example is the password
format for user ID registration, seen in Figure&nbsp;<A HREF="http://www.brics.dk/bigwig/publications/powerform/powerform.html#fig:www9">4</A>,
which is five or more characters not all alphabetic:
<PRE>

  &lt;regexp id="pwd"&gt;
    &lt;intersection&gt;
       &lt;repeat low="5"&gt;&lt;anychar/&gt;&lt;/repeat&gt;
       &lt;complement&gt;
         &lt;star&gt;
           &lt;union&gt;
             &lt;range low="a" high="z"/&gt;
             &lt;range low="A" high="Z"/&gt;
           &lt;/union&gt;
         &lt;/star&gt;
       &lt;/complement&gt;
    &lt;/intersection&gt;
  &lt;/regexp&gt;
</PRE>
or alternatively using the Perl syntax where possible:
<PRE>

  &lt;regexp id="pwd"&gt;
    &lt;intersection&gt;
       &lt;regexp exp=".{5,}"/&gt;
       &lt;complement&gt;
         &lt;regexp exp="[a-zA-Z]*"/&gt;
       &lt;/complement&gt;
    &lt;/intersection&gt;
  &lt;/regexp&gt;
</PRE>
To enforce this format on the existing form, we just add the
declarations:
<PRE>

  &lt;format name="Password1"&gt;&lt;regexp idref="pwd"/&gt;&lt;/format&gt;
  &lt;format name="Password2"&gt;&lt;regexp idref="pwd"/&gt;&lt;/format&gt;
</PRE>

<P></P>
<DIV ALIGN="CENTER"><A NAME="fig:www9"></A><A NAME="316"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 4:</STRONG>
user ID registration.</CAPTION>
<TR><TD><IMG WIDTH="318" HEIGHT="323" BORDER="0" SRC="www9.gif" ALT="user ID registration"></TD></TR>
</TABLE>
</DIV><P></P>
At our Web site we show more advanced examples, such as legal dates
including leap days, URIs, and time of day. As a final example,
consider a simple format for ISBN numbers:
<PRE>

  &lt;regexp id="isbn"&gt;
    &lt;concat&gt;
      &lt;repeat count="9"&gt;
         &lt;concat&gt;
           &lt;range low="0" high="9"/&gt;
           &lt;optional&gt;&lt;charset value=" -"/&gt;&lt;/optional&gt;
         &lt;/concat&gt;
      &lt;/repeat&gt;
      &lt;charset value="0123456789X"/&gt;
    &lt;/concat&gt;
  &lt;/regexp&gt;
</PRE>
or more succinctly:
<PRE>

  &lt;regexp id="isbn"&gt;
    &lt;regexp exp="([0-9]([ -]?)){9}[0-9X]"/&gt;
  &lt;/regexp&gt;
</PRE>
An input field that exploits this format is:
<PRE>

  Enter ISBN number: &lt;input type=text name="isbn" size=20&gt;
  &lt;format name="isbn" 
          help="Enter an ISBN number" 
          error="Illegal ISBN format"&gt;
    &lt;regexp idref="isbn"/&gt;
  &lt;/format&gt;
</PRE>
Initially, the field has a yellow light. This status persists, as seen
in Figure&nbsp;<A HREF="http://www.brics.dk/bigwig/publications/powerform/powerform.html#fig:isbn">5</A>, while we enter the text <TT> "0-444-50264-"</TT>
which is a legal prefix of an ISBN number. Entering another <TT> "-"</TT>
yields a red light.  Deleting this character and entering <TT> 5</TT> will
finally give a legal value and a green light. 

<P>
While the input field has focus, the <TT> help</TT> string appears in the 
status line of the browser. If the client attempts to submit the form
with invalid data in this field, then the <TT> error</TT> text appears in an
alert box.

<P>

<P></P>
<DIV ALIGN="CENTER"><A NAME="fig:isbn"></A><A NAME="341"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 5:</STRONG>
Checking ISBN numbers.</CAPTION>
<TR><TD><IMG WIDTH="378" HEIGHT="158" BORDER="0" SRC="isbn.gif" ALT="Checking ISBN numbers"></TD></TR>
</TABLE>
</DIV><P></P>

<P>
An ISBN format that includes
checksums can be described as a complex regular expression that yields
a 201-state automaton. This full format would only accept <TT> 5</TT> as
the last digit, since that is the correct checksum. Such a regular
expression could hardly be written by hand; in fact, we generated it
using a C program. But as precompiled automata may be saved and provided
as formats, this shows that our technology also allows us to construct
and publish a collection of advanced default formats, similarly to the
datatypes employed in XML Schema&nbsp;[<A
 HREF="http://www.brics.dk/bigwig/publications/powerform/powerform.html#biron99:_xml_schem_part">2</A>] and
the predefined <TT> ctype</TT> formats suggested in&nbsp;[<A
 HREF="http://www.brics.dk/bigwig/publications/powerform/powerform.html#fml">12</A>].

<P>

<H1><A NAME="SECTION00030000000000000000"></A>
<A NAME="sec:interdependencies"></A><BR>
Interdependencies of Form Fields
</H1>

<P>
We present a simple, yet general mechanism for expressing
interdependencies.  We have strived to develop a purely declarative
notation that requires no programming skills.  Our proposal is based
on dynamically evolving formats that are settled through a fixed-point
process.

<P>

<H2><A NAME="SECTION00031000000000000000">
Syntax</A>
</H2>

<P>
We extend the syntax for formats as follows:<TT></TT><PRE><TT>
&nbsp;&nbsp;<I>formatdecl</I> ::= &lt;format name=<I>stringconst</I>&gt; <I>format</I> &lt;/format&gt;
<BR>
<BR>&nbsp;&nbsp;<I>format</I>     ::= <I>regexp</I> |
<BR>		 &lt;if&gt; <I>boolexp</I> 
<BR>		 &nbsp;&nbsp;&nbsp;&lt;then&gt; <I>format</I> &lt;/then&gt;
<BR>		 &nbsp;&nbsp;&nbsp;&lt;else&gt; <I>format</I> &lt;/else&gt;
<BR>		 &lt;/if&gt; |
<BR>		 &lt;format id=<I>stringconst</I>&gt; <I>format</I> &lt;/format&gt; |
<BR>		 &lt;format idref=<I>stringconst</I>/&gt;
<BR>
<BR>&nbsp;&nbsp;<I>boolexp</I>    ::= &lt;match name=<I>stringconst</I>&gt; <I>regexp</I> &lt;/match&gt; |
<BR>		 &lt;equal name=<I>stringconst</I> value=<I>stringconst</I>/&gt; |
<BR>		 &lt;and&gt; <I>boolexp</I>* &lt;/and&gt; |
<BR>		 &lt;or&gt; <I>boolexp</I>* &lt;/or&gt; |
<BR>		 &lt;not&gt; <I>boolexp</I>* &lt;/not&gt;
</TT></PRE><TT></TT>

Now, the format that applies to a given field is dependent on the
values of other fields.  The specification is a binary decision tree,
whose leaves are regular expressions and whose internal nodes are
boolean expressions. Each boolean expression is a propositional
combination of the primitive <TT> match</TT> and <TT> equal</TT> elements that
each test the field indicated by <TT> name</TT>. Even this simple language
is more advanced than required for most uses.

<P>

<H2><A NAME="SECTION00032000000000000000">
Semantics of boolean expressions</A>
</H2>

<P>
A boolean expression evaluates to true or false.  For a <TT> text</TT> or
<TT> password</TT> field, <TT> equal</TT> is true iff its current value equals
<TT> value</TT>; <TT> match</TT> is true iff its current value is a member of
the set denoted by <TT> regexp</TT>.  For a <TT> select</TT> field, <TT> 
  equal</TT> is true iff the value of a currently selected option equals
<TT> value</TT>; <TT> match</TT> is true iff the value of a currently selected
option is a member of the set denoted by <TT> regexp</TT>.  For a
collection of <TT> radio</TT> or <TT> checkbox</TT> fields, <TT> equal</TT> is
true iff a button whose value equals <TT> value</TT> is currently
depressed; <TT> match</TT> is true iff a button whose value is a member of
the set denoted by <TT> regexp</TT> is currently depressed.

<P>
For the boolean operators, <TT> and</TT> is true iff all of its children are true,
<TT> or</TT> is true if one of its children is true, and <TT> not</TT> is true if
all of its children are false.

<P>

<H2><A NAME="SECTION00033000000000000000">
Semantics of interdependencies</A>
</H2>

<P>
Given a collection of form fields <em>F<sub>1</sub></em>, ..., <em>F<sub>n</sub></em> with associated
formats and values, we define an <EM> iteration</EM> which in order does
the following for each <em>F<sub>i</sub></em> :

  <UL>
<LI>evaluate the current format based on the current values of all
  form fields;</LI>
<LI>update the field based on the new current format.</LI>
</UL>
The updating varies with the type of the form field:

<UL>
<LI>for a <TT> text</TT> field, the status light is changed to reflect
  the relationship between the current value and the current format;</LI>
<LI>for a <TT> select</TT> field, the options are filtered by the new
  format, and the selected options that are no longer allowed by the
  format are unselected; if the current selection of a singular <TT> 
    select</TT> is disallowed, the <TT> error</TT> option is selected;</LI>
<LI>for a <TT> radio</TT> or <TT> checkbox</TT> field, a depressed button is
  released if its value is no longer allowed by the format.</LI>
</UL>
An iteration is <EM> monotonic</EM>, which intuitively means that it can
only delete user data. Technically, an iteration is a monotonic
function on a specific lattice of form status descriptions.  It
follows that repeated iteration will eventually reach a fixed-point.
In fact, if <em>b</em> is the total number of <TT> radio</TT> and <TT> checkbox</TT>
buttons, <em>p</em> is the total number of <TT> select</TT> options, and <em>s</em> is
the number of singular <TT> select</TT>s, then at most <em>b+p+s+1</em>
iterations are required. Usually, however, the fixed-point will
stabilize after very few iterations; also, a compile-time dependency
analysis can keep this number down.  Only complex forms with a high
degree of interdependency will require many iterations.

<P>
The behavior of a PowerForm is to iterate to a new fixed-point
whenever the client changes an input field; furthermore, the form data
can only be submitted when all the form fields are in a status that
allows this.

<P>
Note that the fixed-point we obtain is dependent on the order in which
the form fields are updated: permuting the fields may result in a
different fixed-point.  We choose to update the fields in the textual
order in which they appear in the document. This is typically the
order in which the client is supposed to consider them, and the
resulting fixed-point appears to coincide with the intuitively
expected behavior. For simpler forms, the order is usually not
significant.

<P>
With form interdependency it is not only possible to create a
deadlocked form that can never be submitted, but also to create
buttons that can never be depressed. Consider again the example from
Section&nbsp;<A HREF="http://www.brics.dk/bigwig/publications/powerform/powerform.html#sec:validation">2</A>. Since the value <TT> aaa</TT> is different
from <TT> bbb</TT>, the <TT> foo</TT> button will instantly be released
whenever it is depressed. Such behavior can of course also stem from
more complicated interdependent behavior.

<P>
The possible behaviors of PowerForms can in principle be analyzed
statically.  Define the size <em>|R|</em> of a regular expression to be the
number of states in the corresponding minimal, deterministic
finite-state automaton, and the size <em>|F|</em> of an input field to be the
product of the sizes of all regular expressions that it may be tested
against. Then a collection of input fields 

<em>F<sub>1</sub>, ...,F<sub>n</sub></em> determines
a finite transition system with 
<em>|F<sub>1</sub>| * |F<sub>2</sub>| * ... * |F<sub>n</sub>|</em>
states for
which the reachability problem is decidable but hardly feasible in
practice. We therefore leave it to the Web author to avoid aberrant
behavior.

<P>

<H2><A NAME="SECTION00034000000000000000">
Examples</A>
</H2>

<P>
As a first example, we will redo the questionnaire from
Figure&nbsp;<A HREF="http://www.brics.dk/bigwig/publications/powerform/powerform.html#fig:questionnaire">1</A>:
<PRE>

  Have you attended past WWW conferences? 
  &lt;input type="radio" name="past" value="yes"&gt;Yes
  &lt;input type="radio" name="past" value="no"&gt;No
  &lt;br&gt;
  &amp;nbsp;If Yes, how did WWW8 compare?
  &lt;input type="radio" name="compare" value="better"&gt;Better
  &lt;input type="radio" name="compare" value="same"&gt;Same
  &lt;input type="radio" name="compare" value="worse"&gt;Worse
</PRE>
To obtain the desired interdependence, we declare the following
format:
<PRE>

  &lt;format name="compare"&gt;
     &lt;if&gt;&lt;equal name="past" value="yes"/&gt;
       &lt;then&gt;&lt;complement&gt;&lt;const value=""/&gt;&lt;/complement&gt;&lt;/then&gt;
       &lt;else&gt;&lt;empty/&gt;&lt;/else&gt;
     &lt;/if&gt;
  &lt;/format&gt;
</PRE>
Only if the first question is answered in the positive, may the
second group of radio buttons may be depressed and an answer is also required.
A second example
shows how radio buttons may filter the options in a selection:
<PRE>

  Favorite letter group: 
  &lt;input type="radio" name="group" value="vowel" checked&gt;vowels
  &lt;input type="radio" name="group" value="consonant"&gt;consonants
  &lt;br&gt;
  Favorite letter: 
  &lt;select name="letter"&gt;
    &lt;option value="a"&gt;a
    &lt;option value="b"&gt;b
    &lt;option value="c"&gt;c
    ...
    &lt;option value="x"&gt;x
    &lt;option value="y"&gt;y
    &lt;option value="z"&gt;z
  &lt;/select&gt;
</PRE>
The unadorned version of this form allows inconsistent choices such as
<TT> group</TT> having value <TT> vowel</TT> and <TT> letter</TT> having value
<TT> z</TT>.  However, we can add the following format:
<PRE>

  &lt;format name="letter"&gt;
    &lt;if&gt;&lt;equal name="group" value="vowel"/&gt;
      &lt;then&gt;&lt;charset value="aeiouy"/&gt;&lt;/then&gt;
      &lt;else&gt;&lt;charset value="bcdfghjklmnpqrstvwxz"/&gt;&lt;/else&gt;
    &lt;/if&gt;
  &lt;/format&gt;
</PRE> 

Apart from enforcing consistency, the induced behavior will make sure
that the client is only presented with consistent options, as shown in
Figure&nbsp;<A HREF="http://www.brics.dk/bigwig/publications/powerform/powerform.html#fig:letter">6</A>.

<P></P>
<DIV ALIGN="CENTER"><A NAME="fig:letter"></A><A NAME="446"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 6:</STRONG>
Only vowels are presented.</CAPTION>
<TR><TD><IMG WIDTH="322" HEIGHT="229" BORDER="0" SRC="letter.gif" ALT="Only vowels are presented"></TD></TR>
</TABLE>
</DIV><P></P>
Next, consider the form:
<PRE>

  &lt;b&gt;Personal info&lt;/b&gt;
  &lt;p&gt;
  Name: &lt;input type="text" name="name" size="30"&gt;&lt;br&gt;
  Birthday: &lt;input type="text" name="birthday" size="20"&gt;&lt;br&gt;
  &lt;table border="0" cellpadding="0" cellspacing="0"&gt;
  &lt;tr&gt;&lt;td valign="top"&gt;Marital status:&lt;/td&gt;
  &lt;td&gt;&lt;input type=radio name="marital" value="single" checked&gt;single
  &lt;br&gt;
  &lt;input type="radio" name="marital" value="married"&gt;married
  &lt;br&gt;
  &lt;input type="radio" name="marital" value="widow"&gt;widow[er]
  &lt;/td&gt;
  &lt;/tr&gt;
  &lt;/table&gt;
  &lt;p&gt;
  &lt;b&gt;Spousal info&lt;/b&gt;
  &lt;p&gt;
  Name: &lt;input type="text" name="spouse" size="30"&gt;&lt;br&gt;
  Deceased &lt;input type="radio" name="deceased" value="deceased"&gt;
</PRE>

<P></P>
<DIV ALIGN="CENTER"><A NAME="fig:marital"></A><A NAME="457"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 7:</STRONG>
Collecting personal information.</CAPTION>
<TR><TD><IMG WIDTH="383" HEIGHT="312" BORDER="0" SRC="marital.gif" ALT="Collecting personal information"></TD></TR>
</TABLE>
</DIV><P></P>
Several formats can be used here. For the birthday, we select from
our standard library a 35-state automaton recognizing
legal dates including leap days:
<PRE>

  &lt;format name="birthday"&gt;
    &lt;regexp uri="http://www.brics.dk/bigwig/powerforms/date.dfa"/&gt;
  &lt;/format&gt;
</PRE>
Among the other fields, there are some obvious interdependencies.
Spousal info is only relevant if the <TT> marital</TT> status is not <TT> 
  single</TT>, and the spouse can only be <TT> deceased</TT> if the <TT> marital</TT> status is <TT> widow</TT>: 
<PRE>

  &lt;format name="spouse"&gt;
    &lt;if&gt;&lt;equal name="marital" value="married"/&gt;
      &lt;then&gt;&lt;regexp idref="handle"/&gt;&lt;/then&gt;
      &lt;else&gt;
        &lt;if&gt;&lt;equal name="marital" value="single"/&gt;
          &lt;then&gt;&lt;empty/&gt;&lt;/then&gt;
          &lt;else&gt;&lt;regexp idref="handle"/&gt;&lt;/else&gt;
        &lt;/if&gt;
      &lt;/else&gt;
    &lt;/if&gt;
  &lt;/format&gt;

  &lt;format name="deceased"&gt;
    &lt;if&gt;&lt;equal name="marital" value="widow"/&gt;
      &lt;then&gt;&lt;const value="deceased"/&gt;&lt;/then&gt;
      &lt;else&gt;&lt;empty/&gt;&lt;/else&gt;
    &lt;/if&gt;
  &lt;/format&gt;
</PRE>
Here, <TT> handle</TT> refers to some regular expression for the names of
people. Note that if the <TT> marital</TT> status changes from <TT> widow</TT>
to <TT> single</TT>, then the <TT> deceased</TT> button will automatically be
released. Dually, it seems reasonable that after a change from <TT> single</TT> to 
<TT> widow</TT>, the <TT> deceased</TT> button should automatically be depressed. 
However, such action is generally not meaningful, since it may cause the
form to oscillate between two settings. In our formalism, this
would violate the monotonicity property that guarantees termination of the fixed-point 
iteration. Still, the form cannot be submitted until the <TT> deceased</TT> button 
is depressed for a <TT> widow</TT>. The initial form is shown in
Figure&nbsp;<A HREF="http://www.brics.dk/bigwig/publications/powerform/powerform.html#fig:marital">7</A>.

<P></P>
<DIV ALIGN="CENTER"><A NAME="fig:phone"></A><A NAME="487"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 8:</STRONG>
Collecting customer information.</CAPTION>
<TR><TD><IMG WIDTH="281" HEIGHT="287" BORDER="0" SRC="phone.gif" ALT="Collecting customer information"></TD></TR>
</TABLE>
</DIV><P></P>

<P>
An example of a more complex boolean expression involves the form in
Figure&nbsp;<A HREF="http://www.brics.dk/bigwig/publications/powerform/powerform.html#fig:phone">8</A>.  Here, simple formats determine that the
correct style of phone numbers is used for the chosen country. The
option of requesting a visit from the NYC office is only open to those
customers who live in New York City. This constraint is enforced by
the following format:
<PRE>

  &lt;format name="nyc"&gt;
    &lt;if&gt;&lt;and&gt;&lt;equal name="country" value="US"/&gt;
             &lt;match name="phone"&gt;
                &lt;concat&gt;
                  &lt;union&gt;
                    &lt;const value="212"/&gt;
                    &lt;const value="347"/&gt;
                    &lt;const value="646"/&gt;
                    &lt;const value="718"/&gt;
                    &lt;const value="917"/&gt;
                  &lt;/union&gt;
                  &lt;anything/&gt;
                &lt;/concat&gt;
             &lt;/match&gt;
        &lt;/and&gt;
     &lt;then&gt;&lt;anything/&gt;&lt;/then&gt;
     &lt;else&gt;&lt;empty/&gt;&lt;/else&gt;
    &lt;/if&gt;
  &lt;/format&gt;
</PRE>
Residents from other cities will find that they cannot depress the
button.

<P>
As a final example of the detailed control that we offer, consider the
form in Figure&nbsp;<A HREF="http://www.brics.dk/bigwig/publications/powerform/powerform.html#fig:license">9</A> which invites users to request a new
version of a product.  Until the client has stated whether he has a
license or not, it is impossible to choose a version.  Once the choice
has been made, licensed users can choose between all versions, others
are limited to versions 1.1 and 1.2. The format on the last group of
radio buttons is:

<P>
 
<PRE>

  &lt;format name="version"&gt;
    &lt;if&gt;&lt;equal name="license" value="yes"/&gt;
        &lt;then&gt;&lt;anything/&gt;&lt;/then&gt;
        &lt;else&gt;
          &lt;if&gt;&lt;equal name="license" value="no"/&gt;
              &lt;then&gt;&lt;union&gt;
                      &lt;const value="1.1"/&gt;
                      &lt;const value="1.2"/&gt;
                    &lt;/union&gt;
              &lt;/then&gt;
              &lt;else&gt;&lt;empty/&gt;&lt;/else&gt;
          &lt;/if&gt;
        &lt;/else&gt;
    &lt;/if&gt;
  &lt;/format&gt;
</PRE>

<P></P>
<DIV ALIGN="CENTER"><A NAME="fig:license"></A><A NAME="505"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 9:</STRONG>
Collecting user information.</CAPTION>
<TR><TD><IMG WIDTH="262" HEIGHT="99" BORDER="0" SRC="license.gif" ALT="Collecting user information"></TD></TR>
</TABLE>
</DIV><P></P>

<P>

<H1><A NAME="SECTION00040000000000000000"></A>
<A NAME="sec:avoidingmore"></A><BR>
Applet results
</H1>
Java applets can be used in conjunction with forms to implement new
GUI components that collect data from the client. However, it is not
obvious how to extract and validate data from an applet and submit it to the server
on equal footing with ordinary form data.

<P>
We propose a simple mechanism for achieving this goal. We extend the
applet syntax to allow <TT> result</TT> elements in addition to <TT> param</TT> elements. 
An example is the following:
<PRE>

  &lt;applet codebase="http://www.brics.dk/bigwig/powerapplets" 
          code="slidebar.class"&gt;
     &lt;param name="low" value="32"&gt;
     &lt;param name="high" value="212"&gt;
     &lt;result name="choice"&gt;
  &lt;/applet&gt;
</PRE>
When this applet is displayed, it shows a slide bar ranging over the
interval [32..212].  When the form is submitted, the applet will be
requested to supply a value for the <TT> choice</TT> result. This value is
then assigned to a <TT> hidden</TT> form field named <TT> choice</TT> and will
now appear with the rest of the form data. If the applet is not ready
with the result, then the form cannot be submitted.

<P>
This extension only works for applets that are subclasses of the
special class <TT> PowerApplet</TT> that we supply. It implements the
method <TT> putResult</TT> that is used by the applet programmer to supply
results, as well as the methods <TT> resultsReady</TT> and <TT> getResult</TT>
that are called by the JavaScript code that implements the form
submission.

<P>
In relation to PowerForms, applet results play the same role as input
fields.  Thus, they can have associated formats and be tested in
boolean expressions. The value of an optional <TT> error</TT> attribute 
will appear in the alert box if an attempt is made to submit the
form with a missing or invalid applet result.

<P>

<H1><A NAME="SECTION00050000000000000000"></A>
<A NAME="sec:translation"></A><BR>
Translation to JavaScript
</H1>

<P>
A PowerForms document is parsed according to a very liberal HTML
grammar that explicitly recognizes the special elements such as <TT> 
  format</TT> and <TT> regexp</TT>.  The generated HTML document retains most
of the original structure, except that it contains the generated
JavaScript code. Also, each input field is modified to include <TT> 
  onKeyup</TT>, <TT> onChange</TT>, and <TT> onClick</TT> functions that react to
modifications from the client.

<P>
A function <TT> update_foo</TT> is defined for each input field name <TT> 
  foo</TT>. This function checks if the current data is valid and reacts
accordingly. Another function <TT> update_all</TT> is responsible for
computing the global fixed-point.

<P>
Each regular expression is by the compiler transformed into a minimal,
deterministic finite-state automaton, which is directly represented in
a JavaScript data structure. It is a simple matter to use an automaton
for checking if a data value is valid. For <TT> text</TT> and <TT> 
  password</TT> fields, the status lights green, yellow, and red
correspond to respectively an accept state, a non-accept state, and
the crash state. For efficiency, the generated automata are time-stamped and
cached locally; thus, they are only recompiled when necessary.

<P>
The generated code is quite small, but relies on a 500 line standard
library with functions for manipulating automata and the Document
Object Model&nbsp;[<A
 HREF="http://www.brics.dk/bigwig/publications/powerform/powerform.html#documentobjectmodel">1</A>].

<P>

<H1><A NAME="SECTION00060000000000000000"></A>
<A NAME="sec:package"></A><BR>
Availability
</H1>

<P>
The PowerForms system is freely available in an open source
distribution from our Web site located at <A NAME="tex2html15"
 HREF="http://www.brics.dk/bigwig/powerforms/"><TT> 
    http://www.brics.dk/bigwig/powerforms/</TT></A>.
The package includes documentation, the examples from this paper and
many more, and the compiler itself which is written in 4000 lines of
C. The generated JavaScript code has been tested for Netscape on Unix
and Windows and for Explorer on Windows.

<P>
PowerForms are also directly supported by the <TT> &lt;bigwig&gt;</TT> system which
is a high-level language for generating interactive Web
services&nbsp;[<A
 HREF="http://www.brics.dk/bigwig/publications/powerform/powerform.html#bigwig99">4</A>,<A
 HREF="http://www.brics.dk/bigwig/publications/powerform/powerform.html#runtime99">3</A>,<A
 HREF="http://www.brics.dk/bigwig/publications/powerform/powerform.html#dyndoc99">11</A>,<A
 HREF="http://www.brics.dk/bigwig/publications/powerform/powerform.html#conccur98">10</A>].  It is likewise
available at <A NAME="tex2html16"
 HREF="http://www.brics.dk/bigwig/"><TT> 
    http://www.brics.dk/bigwig/</TT></A>.

<P>

<H1><A NAME="SECTION00070000000000000000"></A>
<A NAME="sec:conclusion"></A><BR>
Conclusion
</H1>

<P>
We have shown how to enrich HTML forms with simple, declarative
concepts that capture advanced input validation and field
interdependencies. Such forms are subsequently compiled into
JavaScript and standard HTML. This allows the design of more
complex and interesting forms while avoiding tedious and 
error-prone JavaScript programming. 

<P>
We would like to thank the entire <TT> &lt;bigwig&gt;</TT> team for 
assisting in experiments with PowerForms.
Thanks also goes to the PowerForms users, in particular Frederik Esser,
for valuable feedback.

<P>

<H2><A NAME="SECTION00080000000000000000">
Bibliography</A>
</H2><DL COMPACT><DD><P></P><DT><A NAME="documentobjectmodel">1</A>
<DD>
Vidur Apparao et al.
<BR><EM> Document Object Model (DOM) Level 1 Specification</EM>.
<BR>W3C, 1998.
<BR>URL: <A NAME="tex2html17"
 HREF="http://www.w3.org/TR/REC-DOM-Level-1
/"><TT> 
  http://www.w3.org/TR/REC-DOM-Level-1/</TT></A>.

<P></P><DT><A NAME="biron99:_xml_schem_part">2</A>
<DD>
Paul V. Biron and Ashok Malhotra.
<BR>XML Schema part 2: Datatypes.
<BR>Technical report, W3C, May 1999.
<BR>World Wide Web Consortium Working Draft.

<P></P><DT><A NAME="runtime99">3</A>
<DD>
Claus Brabrand, Anders M&#248;ller, Anders Sandholm, and Michael I. Schwartzbach.
<BR>A runtime system for interactive Web services.
<BR><EM> Computer Networks</EM>, 31:1391-1401, 1999.
<BR>Also in proceedings of WWW8.

<P></P><DT><A NAME="bigwig99">4</A>
<DD>
Claus Brabrand, Anders M&#248;ller, Anders Sandholm, and Michael I. Schwartzbach.
<BR>Designing a language for developing interactive Web services, 2000.
<BR>URL: <A NAME="tex2html18"
 HREF="http://www.brics.dk/bigw
ig/research/publications/"><TT> 
  http://www.brics.dk/bigwig/research/publications/</TT></A>.

<P></P><DT><A NAME="bray98:_exten_markup_languag_xml">5</A>
<DD>
Tim Bray, Jean Paoli, and C. M. Sperberg-McQueen, editors.
<BR><EM> Extensible Markup Language (XML) 1.0</EM>.
<BR>W3C, February 1998.
<BR>URL: <A NAME="tex2html19"
 HREF="http://www.w3.org/TR/REC-xml"><TT> 
  http://www.w3.org/TR/REC-xml</TT></A>.

<P></P><DT><A NAME="javascript-lib">6</A>
<DD>
Netscape Corp.
<BR>JavaScript form validation sample code.
<BR>URL: <A NAME="tex2html20"
 HREF="http://developer.netscape.com/docs/examples/javascript/formval
/overview.html"><TT> 
  http://developer.netscape.com/docs/examples/<BR>[3]javascript/formval/overview.html</TT></A>.

<P></P><DT><A NAME="coldfusion">7</A>
<DD>
John Desborough.
<BR><EM> Cold Fusion 3.0 Intranet Application</EM>.
<BR>International Thomson Publishing, 1997.

<P></P><DT><A NAME="webdynamicforms">8</A>
<DD>
Andreas Girgensohn and Alison Lee.
<BR>Seamless integration of interactive forms into the web.
<BR>In <EM> Proceedings of WWW6</EM>, 1997.
<BR>URL: <A NAME="tex2html21"
 HREF="http://www.scope.gmd.de/info/www6/technical/paper083/paper83.html"><TT> 
  http://www.scope.gmd.de/info/www6/technical/<BR>[3]paper083/paper83.ht
ml</TT></A>.

<P></P><DT><A NAME="javascript-forms">9</A>
<DD>
Jukka Korpela.
<BR>JavaScript and HTML: possibilities and caveats.
<BR>URL: <A NAME="tex2html22"
 HREF="http://www.hut.fi/u/jko
rpela/forms/javascript.html"><TT> 
  http://www.hut.fi/u/jkorpela/forms/javascript.html</TT></A>.

<P></P><DT><A NAME="conccur98">10</A>
<DD>
Anders Sandholm and Michael I. Schwartzbach.
<BR>Distributed safety controllers for Web services.
<BR>In <EM> Fundamental Approaches to Software Engineering, FASE'98</EM>,
  LNCS 1382, pages 270-284. Springer-Verlag, March/April 1998.

<P></P><DT><A NAME="dyndoc99">11</A>
<DD>
Anders Sandholm and Michael I. Schwartzbach.
<BR>A domain specific language for typed dynamic documents.
<BR>In <EM> Proceedings of POPL'00</EM>, 2000.

<P></P><DT><A NAME="fml">12</A>
<DD>
Sebastian Schnitzenbaumer, Malte Wedel, and Muditha Gunatilake, editors.
<BR><EM> XHTML-FML 1.0: Forms Markup Language</EM>.
<BR>Stack Overflow AG, 1999.
<BR>URL: <A NAME="tex2html23"
 HREF="http://www.mozq
uito.org/documentation/spec_xhtml-fml.html"><TT> 
  http://www.mozquito.org/documentation/spec_xhtml-fml.html</TT></A>.

<P></P><DT><A NAME="xhtml-forms">13</A>
<DD>
Sebastian Schnitzenbaumer, Malte Wedel, and Dave Raggett, editors.
<BR><EM> XHTML Extended Forms Requirements</EM>.
<BR>W3C, 1999.
<BR>URL: <A NAME="tex2html24"
 HREF="http://www.w3.org/TR/xhtml-forms
-req.html"><TT> 
  http://www.w3.org/TR/xhtml-forms-req.html</TT></A>.

<P></P><DT><A NAME="activeforms">14</A>
<DD>
Paul Thistlewaite and Steve Ball.
<BR>Active forms.
<BR>In <EM> Proceedings of WWW5</EM>, 1996.
<BR>URL: <A NAME="tex2html25"
 HREF="http://www5conf.inria.fr/fich_html/papers/P40/Overview.html"><TT> 
  http://www5conf.inria.fr/fich_html/papers/P40/<BR>[3]Overview.html</TT></A>.

<P></P><DT><A NAME="javascript-faq">15</A>
<DD>
Martin Webb and Michel Plungjan.
<BR>JavaScript form FAQ knowledge base.
<BR>URL: <A NAME="tex2html26"
 HREF="http://developer.irt.org/script/f
orm.htm"><TT> 
  http://developer.irt.org/script/form.htm</TT></A>.
</DL>

<P>

</BODY>
</HTML>
